<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KIRILMA | Candy Puzzle</title>
    <style>
        :root {
            --bg-color: #2b1d38; /* Koyu Mor/M√ºrd√ºm Arkaplan */
            --panel-bg: #402a52;
            --text-main: #ffffff;
            --text-muted: #dccae8;
            
            --border-color: #593a73;
            --tile-size: 58px; /* Biraz daha b√ºy√ºk */
            --gap: 4px;
            
            --font-ui: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Daha modern, yumu≈üak font */
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            background: radial-gradient(circle at center, #3c2a4d 0%, #1a1025 100%);
            color: var(--text-main);
            font-family: var(--font-ui);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* Pixelated kaldƒ±rƒ±ldƒ±, yumu≈üak ge√ßi≈üler i√ßin */
        }

        /* Layout Structure */
        #app {
            width: 100%;
            max-width: 600px;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            position: relative;
            z-index: 10;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin-bottom: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        h1 {
            margin: 0;
            font-size: 1.8rem;
            font-weight: 800;
            background: linear-gradient(to bottom, #fff, #ffd1ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }

        .level-badge {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%);
            color: #d63384;
            padding: 5px 15px;
            font-weight: bold;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .icon-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }
        .icon-btn:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }

        /* Main Game Area */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            overflow: hidden;
        }

        /* Game Board */
        #game-board-container {
            position: relative;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5), inset 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid rgba(255,255,255,0.05);
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--gap);
            width: fit-content;
            touch-action: none;
        }

        /* --- CANDY TILE STYLES --- */
        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            background: transparent;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s;
            will-change: transform;
            /* Hafif g√∂lge ile havada durma hissi */
            filter: drop-shadow(0px 4px 3px rgba(0,0,0,0.4));
        }
        
        /* T√ºm ≈üekerlerin ortak i√ß yapƒ±sƒ± (Parlaklƒ±k ve 3D) */
        .tile::before {
            content: '';
            position: absolute;
            width: 90%; height: 90%;
            border-radius: inherit; /* ≈ûekli ebeveyninden al */
            box-shadow: 
                inset 0px -4px 6px rgba(0,0,0,0.3), /* Alt g√∂lge */
                inset 2px 2px 5px rgba(255,255,255,0.6), /* √úst parƒ±ltƒ± */
                inset 0 0 10px rgba(0,0,0,0.1); 
            z-index: 1;
        }
        
        /* Ekstra "High Gloss" parƒ±ltƒ±sƒ± */
        .tile::after {
            content: '';
            position: absolute;
            top: 20%; left: 20%;
            width: 25%; height: 15%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0.1));
            border-radius: 50%;
            transform: rotate(-45deg);
            pointer-events: none;
            z-index: 2;
        }

        /* --- ≈ûEKER Tƒ∞PLERƒ∞ --- */

        /* Kƒ±rmƒ±zƒ± (Jelly Bean) */
        .tile[data-type="0"]::before {
            background: radial-gradient(circle at 35% 35%, #ff758c, #d6334c);
            border-radius: 40% 40% 45% 45% / 55% 55% 40% 40%;
        }
        
        /* Mavi (Yuvarlak Lolipop) */
        .tile[data-type="1"]::before {
            background: radial-gradient(circle at 30% 30%, #4facfe, #00f2fe);
            border-radius: 50%;
        }

        /* Ye≈üil (Kare Yastƒ±k) */
        .tile[data-type="2"]::before {
            background: radial-gradient(circle at 30% 30%, #a8e063, #56ab2f);
            border-radius: 12px; /* Hafif yuvarlatƒ±lmƒ±≈ü kare */
        }

        /* Sarƒ± (Limon/Damlacƒ±k) */
        .tile[data-type="3"]::before {
            background: radial-gradient(circle at 40% 40%, #fff200, #ffc300);
            border-radius: 50%;
            /* Sarƒ±ya √∂zel ≈üekil: √ústten biraz basƒ±k */
            clip-path: ellipse(45% 50% at 50% 50%); /* Basit elips */
        }
        /* Sarƒ± i√ßin ::after parƒ±ltƒ±sƒ±nƒ± d√ºzelt */
        .tile[data-type="3"]::after { top: 25%; left: 25%; }

        /* Mor (√ái√ßek/Halka) */
        .tile[data-type="4"]::before {
            background: radial-gradient(circle at 30% 30%, #e0c3fc, #8ec5fc);
            background: radial-gradient(circle at 30% 30%, #cd93ff, #6a11cb);
            border-radius: 50%;
            border: 4px solid rgba(255,255,255,0.2); /* Halka efekti */
            box-sizing: border-box;
        }

        /* Efektler */
        .tile.selected { transform: scale(1.15); filter: drop-shadow(0 0 10px gold); z-index: 10; }
        .tile.matched { animation: pop 0.3s forwards; }
        
        .tile.cracked::before {
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(0,0,0,0.3) 5px, rgba(0,0,0,0.3) 6px);
        }

        /* HUD Panel */
        #hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            gap: 10px;
            padding: 0 5px;
        }

        .panel {
            flex: 1;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .stat-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; font-weight: 600; letter-spacing: 0.5px; }
        .stat-value { font-size: 1.4rem; font-weight: 800; color: #fff; margin-top: 2px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        
        .twist-panel { 
            position: absolute; top: 75px; left: 50%; transform: translateX(-50%);
            width: 90%; z-index: 5;
            background: rgba(0,0,0,0.8); border: 1px solid #ffcc00; border-radius: 20px;
            display: none; padding: 8px 15px; text-align: center;
            font-size: 0.8rem; color: #ffcc00; font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        .goal-item { display: flex; align-items: center; gap: 8px; margin-top: 5px; font-size: 1rem; font-weight: bold;}
        
        /* Mini hedefler i√ßin basit CSS daireleri */
        .mini-tile { width: 20px; height: 20px; border-radius: 50%; box-shadow: inset -2px -2px 5px rgba(0,0,0,0.2); }

        .btn {
            background: linear-gradient(to bottom, #4facfe 0%, #00f2fe 100%);
            border: none;
            color: #fff;
            padding: 12px;
            width: 100%;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.2);
            font-size: 0.9rem;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); }
        
        .btn-boost { background: linear-gradient(to bottom, #f093fb 0%, #f5576c 100%); }
        .btn-secondary { background: rgba(255,255,255,0.1); font-size: 0.8rem; padding: 10px; border: 1px solid rgba(255,255,255,0.1);}

        /* Tokens */
        #token-display { display: flex; align-items: center; gap: 6px; font-weight: bold; color: #ffd700; background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 15px; }
        .token-icon { width: 14px; height: 14px; background: #ffd700; border-radius: 50%; box-shadow: inset -2px -2px 5px rgba(0,0,0,0.4); border: 1px solid #fff; }

        /* Overlays */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(20, 10, 30, 0.9);
            backdrop-filter: blur(8px);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .overlay.active { display: flex; animation: fadeIn 0.3s; }
        .overlay-content { 
            width: 85%; padding: 25px; 
            background: linear-gradient(135deg, #2b1d38, #1a1025);
            border: 1px solid rgba(255,255,255,0.1); 
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }
        
        .overlay h2 { font-size: 2.2rem; margin-bottom: 15px; text-shadow: 0 4px 10px rgba(0,0,0,0.5); margin-top:0; }
        .win-title { background: linear-gradient(to right, #a8e063, #56ab2f); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .lose-title { background: linear-gradient(to right, #ff758c, #d6334c); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        
        /* Boost Drawer */
        #boost-drawer {
            position: absolute; bottom: -350px; left: 0; width: 100%; height: auto;
            background: #251830; 
            border-top: 2px solid rgba(255,255,255,0.1);
            border-radius: 20px 20px 0 0;
            z-index: 50; transition: bottom 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            padding: 20px; box-shadow: 0 -10px 40px rgba(0,0,0,0.6);
        }
        #boost-drawer.open { bottom: 0; }

        .boost-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px; border-radius: 10px; background: rgba(255,255,255,0.05);
            margin-bottom: 10px; cursor: pointer; border: 1px solid transparent;
        }
        .boost-item:active { background: rgba(255,255,255,0.1); }
        .boost-item span b { color: #f093fb; }

        footer {
            margin-top: auto; width: 100%; padding: 10px;
            display: flex; justify-content: space-between;
            font-size: 0.8rem; color: rgba(255,255,255,0.5);
        }

        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.3); opacity: 1; } 100% { transform: scale(0); opacity: 0; } }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-40px) scale(1.2); opacity: 0; } }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        .float-text {
            position: absolute; color: #fff; font-weight: 900; font-size: 1.5rem;
            pointer-events: none; animation: floatUp 0.6s ease-out forwards; z-index: 20;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            background: linear-gradient(to bottom, #fff, #ffd1ff); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        /* Responsive */
        @media (max-width: 768px) {
            :root { --tile-size: 11.5vw; --gap: 3px; }
            #hud { padding: 0; }
        }

    </style>
</head>
<body>

<div id="app">
    <header>
        <h1>KIRILMA</h1>
        <div class="level-badge" id="level-display">SEVƒ∞YE 1</div>
        <div style="display:flex; gap:8px; align-items: center;">
            <div id="token-display"><div class="token-icon"></div> <span id="token-count">0</span></div>
            <button class="icon-btn" onclick="Game.ui.toggleSettings()">‚öôÔ∏è</button>
        </div>
    </header>

    <main>
        <div class="twist-panel" id="twist-panel">
            <span id="twist-desc">...</span>
        </div>

        <div id="hud">
            <div class="panel">
                <div class="stat-label">HAMLE</div>
                <div class="stat-value" id="moves-display">20</div>
            </div>
            
            <div class="panel">
                <div class="stat-label">HEDEF</div>
                <div id="goal-container"></div>
            </div>

            <div class="panel">
                <div class="stat-label">PUAN</div>
                <div class="stat-value" style="font-size: 1.2rem" id="score-display">0</div>
            </div>
        </div>

        <div id="game-board-container">
            <div id="grid"></div>
        </div>

        <div style="width:100%; display: flex; gap: 10px; margin-top: 5px; padding: 0 5px;">
            <button class="btn btn-boost" onclick="Game.ui.toggleBoostDrawer()">‚ö° G√ú√áLENDƒ∞Rƒ∞Cƒ∞</button>
            <button class="btn btn-secondary" style="width: 80px;" onclick="Game.logic.restartLevel()">‚Ü∫</button>
        </div>
    </main>

    <footer>
        <button class="icon-btn" id="sound-toggle" style="background:none; border:none; padding:0;" onclick="Game.audio.toggle()">üîä</button>
        <span id="tip-text" style="color: rgba(255,255,255,0.4)">Deƒüi≈ütirmek i√ßin s√ºr√ºkleyin</span>
        <button class="icon-btn" style="background:none; border:none; padding:0;" onclick="Game.ui.showHelp()">?</button>
    </footer>

    <!-- Boost Drawer -->
    <div id="boost-drawer">
        <h3 style="color:#fff; margin-top:0; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom:10px; font-size: 1.1rem;">MARKET</h3>
        <button class="icon-btn" onclick="Game.ui.toggleBoostDrawer()" style="position:absolute; top:15px; right:15px; background:rgba(255,255,255,0.1); width:30px; height:30px; display:flex; align-items:center; justify-content:center;">‚úï</button>
        
        <div class="boost-item" onclick="Game.logic.useBooster('move')">
            <span><b>+5 HAMLE</b></span> 
            <span style="color:#ffd700; font-weight:bold;">10 Jeton</span>
        </div>
        
        <div class="boost-item" onclick="Game.logic.useBooster('shuffle')">
            <span><b>KARI≈ûTIR</b></span> 
            <span style="color:#ffd700; font-weight:bold;">15 Jeton</span>
        </div>
        
        <div class="boost-item" onclick="Game.logic.useBooster('smash')">
            <span><b>RENK Sƒ∞L</b> (Kƒ±rmƒ±zƒ±)</span> 
            <span style="color:#ffd700; font-weight:bold;">25 Jeton</span>
        </div>
    </div>
</div>

<!-- Overlays -->
<div id="overlay-main" class="overlay">
    <div class="overlay-content">
        <h2 id="overlay-title">B√ñL√úM GE√áƒ∞LDƒ∞</h2>
        <p id="overlay-msg" style="margin-bottom:25px; font-size:1.1rem; color:#dccae8;"></p>
        <div id="overlay-buttons" style="display:flex; flex-direction:column; gap:10px;"></div>
    </div>
</div>

<div id="overlay-settings" class="overlay">
    <div class="overlay-content">
        <h2>AYARLAR</h2>
        <button class="btn" style="background:#ff5e57; margin-top:10px" onclick="Game.data.resetProgress(); location.reload()">ƒ∞lerlemeyi Sƒ±fƒ±rla</button>
        <button class="btn btn-secondary" style="margin-top:10px" onclick="document.getElementById('overlay-settings').classList.remove('active')">KAPAT</button>
    </div>
</div>

<script>
/**
 * KIRILMA: Candy Edition - Game Logic
 */

const CONSTANTS = {
    ROWS: 8,
    COLS: 8,
    // Colors for Goal HUD (must match tile visual roughly)
    COLORS: ['#ff758c', '#4facfe', '#a8e063', '#fff200', '#cd93ff'], 
    TYPES: [0, 1, 2, 3, 4],
    SWIPE_THRESHOLD: 30
};

const TWISTS = {
    NONE: null,
    BLUE_PHANTOM: { id: 'BLUE_PHANTOM', desc: "Mavi ≈üekerler puan vermez." },
    ANTI_GRAVITY: { id: 'ANTI_GRAVITY', desc: "Yer√ßekimi yok! Bo≈üluklar rastgele dolar." },
    CRACKED_HULL: { id: 'CRACKED_HULL', desc: "≈ûekerler sertle≈üti. Kƒ±rmak i√ßin 2 kez e≈üle." },
    CONTAINMENT: { id: 'CONTAINMENT', desc: "Alan daraldƒ±! (6x6)" },
    SPECTRUM_BAN: { id: 'SPECTRUM_BAN', desc: "Sarƒ± ≈üekerler bu b√∂l√ºmde yok." },
    STICKY_CORE: { id: 'STICKY_CORE', desc: "Yapƒ±≈ükan: Orta sƒ±ra a≈üaƒüƒ± d√º≈ümez." }
};

class GameData {
    constructor() {
        this.level = 1;
        this.tokens = 50;
        this.settings = { sound: true };
        this.load();
    }

    load() {
        const saved = localStorage.getItem('kirilma_candy_save');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.level = parsed.level || 1;
            this.tokens = parsed.tokens || 50;
        }
    }

    save() {
        localStorage.setItem('kirilma_candy_save', JSON.stringify({
            level: this.level,
            tokens: this.tokens
        }));
    }

    resetProgress() {
        localStorage.removeItem('kirilma_candy_save');
    }
}

class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }

    toggle() {
        this.enabled = !this.enabled;
        document.getElementById('sound-toggle').textContent = this.enabled ? 'üîä' : 'üîá';
    }

    playTone(freq, type, duration) {
        if (!this.enabled) return;
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        } catch(e) {}
    }

    playPop() { this.playTone(400, 'sine', 0.1); }
    playMatch() { 
        this.playTone(500, 'sine', 0.1); 
        setTimeout(() => this.playTone(700, 'sine', 0.15), 80);
    }
    playError() { this.playTone(150, 'sawtooth', 0.2); }
    playWin() { 
        [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'sine', 0.2), i*100));
    }
}

class InputController {
    constructor(gameLogic) {
        this.logic = gameLogic;
        this.startX = 0;
        this.startY = 0;
        this.activeTile = null;
        this.isDragging = false;
    }

    attach(element) {
        element.addEventListener('touchstart', (e) => this.handleStart(e.touches[0].clientX, e.touches[0].clientY, e.target), {passive: false});
        element.addEventListener('touchmove', (e) => this.handleMove(e.touches[0].clientX, e.touches[0].clientY, e), {passive: false});
        element.addEventListener('touchend', (e) => this.handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY));

        element.addEventListener('mousedown', (e) => this.handleStart(e.clientX, e.clientY, e.target));
        window.addEventListener('mousemove', (e) => {
            if(this.isDragging) this.handleMove(e.clientX, e.clientY, e);
        });
        window.addEventListener('mouseup', (e) => {
            if(this.isDragging) this.handleEnd(e.clientX, e.clientY);
        });
    }

    getTileFromTarget(target) {
        if(target.classList.contains('tile')) return target;
        return target.closest('.tile');
    }

    handleStart(x, y, target) {
        if (this.logic.isProcessing) return;
        const tileEl = this.getTileFromTarget(target);
        if (!tileEl) return;

        this.startX = x;
        this.startY = y;
        this.activeTile = {
            r: parseInt(tileEl.dataset.r),
            c: parseInt(tileEl.dataset.c),
            el: tileEl
        };
        this.isDragging = true;
        tileEl.style.transform = "scale(0.9)";
    }

    handleMove(x, y, e) {
        if(!this.isDragging) return;
        e.preventDefault();
    }

    handleEnd(x, y) {
        if (!this.isDragging || !this.activeTile) return;
        this.isDragging = false;
        
        this.activeTile.el.style.transform = "";

        const diffX = x - this.startX;
        const diffY = y - this.startY;

        if (Math.abs(diffX) < CONSTANTS.SWIPE_THRESHOLD && Math.abs(diffY) < CONSTANTS.SWIPE_THRESHOLD) {
            return; 
        }

        let targetR = this.activeTile.r;
        let targetC = this.activeTile.c;

        if (Math.abs(diffX) > Math.abs(diffY)) {
            if (diffX > 0) targetC++; else targetC--;
        } else {
            if (diffY > 0) targetR++; else targetR--;
        }

        if (targetR >= 0 && targetR < this.logic.boardSize && targetC >= 0 && targetC < this.logic.boardSize) {
            this.logic.attemptSwap(this.activeTile, {r: targetR, c: targetC});
        } else {
            Game.audio.playError();
        }
        
        this.activeTile = null;
    }
}

class GameLogic {
    constructor() {
        this.grid = [];
        this.isProcessing = false;
        this.score = 0;
        this.moves = 0;
        this.goals = {};
        this.currentTwist = null;
        this.boardSize = 8;
        this.bannedColor = -1;
        
        this.input = new InputController(this);
    }

    initLevel(levelNum) {
        this.score = 0;
        this.moves = Math.max(15, 30 - Math.floor(levelNum / 2));
        this.goals = this.generateGoals(levelNum);
        this.currentTwist = this.getTwistForLevel(levelNum);
        
        this.boardSize = (this.currentTwist === TWISTS.CONTAINMENT) ? 6 : 8;
        this.bannedColor = (this.currentTwist === TWISTS.SPECTRUM_BAN) ? 3 : -1;

        Game.ui.updateLevelInfo(levelNum, this.moves, this.goals, this.currentTwist);
        Game.ui.closeOverlays();
        
        this.createGrid();
        this.resolveMatches(true);
    }

    getTwistForLevel(lvl) {
        if (lvl < 5) return TWISTS.NONE;
        if (lvl >= 5 && lvl < 10) return TWISTS.BLUE_PHANTOM;
        if (lvl >= 10 && lvl < 15) return TWISTS.ANTI_GRAVITY;
        if (lvl >= 15 && lvl < 20) return TWISTS.CRACKED_HULL;
        if (lvl >= 20 && lvl < 25) return TWISTS.CONTAINMENT;
        if (lvl >= 25 && lvl < 30) return TWISTS.SPECTRUM_BAN;
        if (lvl >= 30) return TWISTS.STICKY_CORE;
        return TWISTS.NONE;
    }

    generateGoals(lvl) {
        const targetScore = lvl * 800;
        const colorTarget = 10 + Math.floor(lvl * 1.5);
        if (lvl % 3 === 0) return { score: targetScore };
        if (lvl % 3 === 1) return { color: 0, count: colorTarget };
        return { color: 2, count: colorTarget };
    }

    createGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';
        gridEl.style.gridTemplateColumns = `repeat(${this.boardSize}, 1fr)`;
        this.grid = [];

        for (let r = 0; r < this.boardSize; r++) {
            this.grid[r] = [];
            for (let c = 0; c < this.boardSize; c++) {
                this.grid[r][c] = this.spawnTileData(r, c);
                this.createTileDOM(r, c);
            }
        }
    }

    spawnTileData(r, c) {
        let type;
        do { type = Math.floor(Math.random() * 5); } while (type === this.bannedColor);
        return {
            type: type,
            r: r, c: c,
            el: null,
            cracked: (this.currentTwist === TWISTS.CRACKED_HULL)
        };
    }

    createTileDOM(r, c) {
        const data = this.grid[r][c];
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.type = data.type;
        tile.dataset.r = r;
        tile.dataset.c = c;
        if (data.cracked) tile.classList.add('cracked');
        
        document.getElementById('grid').appendChild(tile);
        data.el = tile;
    }

    attemptSwap(t1Coords, t2Coords) {
        const t1 = this.grid[t1Coords.r][t1Coords.c];
        const t2 = this.grid[t2Coords.r][t2Coords.c];
        this.swapTiles(t1, t2);
    }

    async swapTiles(t1, t2) {
        this.isProcessing = true;
        
        this.grid[t1.r][t1.c] = t2;
        this.grid[t2.r][t2.c] = t1;
        
        const tempR = t1.r, tempC = t1.c;
        t1.r = t2.r; t1.c = t2.c;
        t2.r = tempR; t2.c = tempC;

        this.updateTileVisuals(t1);
        this.updateTileVisuals(t2);

        await this.wait(150);

        const matches = this.findMatches();
        
        if (matches.length > 0) {
            this.moves--;
            Game.ui.updateHUD();
            await this.resolveMatches(false, matches);
        } else {
            Game.audio.playError();
            
            this.grid[t1.r][t1.c] = t2;
            this.grid[t2.r][t2.c] = t1;
            t1.r = t2.r; t1.c = t2.c;
            t2.r = tempR; t2.c = tempC;
            
             const r1 = t1.r; const c1 = t1.c;
            t1.r = t2.r; t1.c = t2.c;
            t2.r = r1; t2.c = c1;

            this.updateTileVisuals(t1);
            this.updateTileVisuals(t2);
            this.isProcessing = false;
        }
    }

    updateTileVisuals(tileData) {
        const el = tileData.el;
        el.dataset.type = tileData.type;
        el.className = 'tile';
        if (tileData.cracked) el.classList.add('cracked');
        el.dataset.r = tileData.r;
        el.dataset.c = tileData.c;
    }

    findMatches() {
        const matches = new Set();
        for (let r = 0; r < this.boardSize; r++) {
            for (let c = 0; c < this.boardSize - 2; c++) {
                const type = this.grid[r][c].type;
                if (type === this.grid[r][c+1].type && type === this.grid[r][c+2].type) {
                    matches.add(this.grid[r][c]); matches.add(this.grid[r][c+1]); matches.add(this.grid[r][c+2]);
                }
            }
        }
        for (let c = 0; c < this.boardSize; c++) {
            for (let r = 0; r < this.boardSize - 2; r++) {
                const type = this.grid[r][c].type;
                if (type === this.grid[r+1][c].type && type === this.grid[r+2][c].type) {
                    matches.add(this.grid[r][c]); matches.add(this.grid[r+1][c]); matches.add(this.grid[r+2][c]);
                }
            }
        }
        return Array.from(matches);
    }

    async resolveMatches(silent = false, initialMatches = null) {
        let matches = initialMatches || this.findMatches();
        let cascadeCount = 0;

        while (matches.length > 0) {
            cascadeCount++;
            if (!silent) {
                Game.audio.playMatch();
                if(cascadeCount > 1) this.showFloatText("HARƒ∞KA!", matches[0].el);
            }

            let tilesToRemove = [];
            for (let t of matches) {
                if (this.currentTwist === TWISTS.BLUE_PHANTOM && t.type === 1) {
                } else if (!silent) {
                    this.score += 10 * cascadeCount;
                    if (this.goals.color !== undefined && this.goals.color === t.type) {
                        this.goals.count = Math.max(0, this.goals.count - 1);
                    }
                }

                if (this.currentTwist === TWISTS.CRACKED_HULL && t.cracked && !silent) {
                    t.cracked = false;
                    this.updateTileVisuals(t);
                } else {
                    tilesToRemove.push(t);
                }
            }

            if (!silent) {
                tilesToRemove.forEach(t => t.el.classList.add('matched'));
                await this.wait(200);
            }

            tilesToRemove.forEach(t => {
                this.grid[t.r][t.c] = null;
                t.el.remove();
            });

            await this.applyGravity();
            matches = this.findMatches();
            if (!silent) Game.ui.updateHUD();
        }

        this.isProcessing = false;
        if (!silent) this.checkGameState();
    }

    async applyGravity() {
        if (this.currentTwist === TWISTS.ANTI_GRAVITY) {
            for (let r = 0; r < this.boardSize; r++) {
                for (let c = 0; c < this.boardSize; c++) {
                    if (this.grid[r][c] === null) {
                        const newData = this.spawnTileData(r, c);
                        this.grid[r][c] = newData;
                        this.createTileDOM(r, c);
                    }
                }
            }
            this.rebuildGridDOM();
            await this.wait(50);
            return;
        }

        for (let c = 0; c < this.boardSize; c++) {
            let emptySlots = 0;
            for (let r = this.boardSize - 1; r >= 0; r--) {
                if (this.currentTwist === TWISTS.STICKY_CORE && (r === 3 || r === 4)) {
                     if (this.grid[r][c] === null) this.grid[r][c] = this.spawnTileData(r, c);
                     continue;
                }
                if (this.grid[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const tile = this.grid[r][c];
                    this.grid[r + emptySlots][c] = tile;
                    tile.r = r + emptySlots;
                    this.grid[r][c] = null;
                }
            }
            for (let r = 0; r < emptySlots; r++) {
                this.grid[r][c] = this.spawnTileData(r, c);
            }
        }
        this.rebuildGridDOM();
        await this.wait(100);
    }

    rebuildGridDOM() {
        const container = document.getElementById('grid');
        container.innerHTML = '';
        for (let r = 0; r < this.boardSize; r++) {
            for (let c = 0; c < this.boardSize; c++) {
                const t = this.grid[r][c];
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.type = t.type;
                if(t.cracked) tile.classList.add('cracked');
                tile.dataset.r = r;
                tile.dataset.c = c;
                t.el = tile;
                container.appendChild(tile);
            }
        }
    }

    checkGameState() {
        let won = false;
        if (this.goals.score && this.score >= this.goals.score) won = true;
        if (this.goals.color !== undefined && this.goals.count <= 0) won = true;

        if (won) {
            Game.audio.playWin();
            Game.ui.showLevelComplete();
            return;
        }
        if (this.moves <= 0) {
            Game.ui.showGameOver();
        }
    }

    useBooster(type) {
        if (this.isProcessing) return;
        const costs = { move: 10, shuffle: 15, smash: 25 };
        if (Game.data.tokens < costs[type]) {
            alert("Yetersiz Jeton!");
            return;
        }
        Game.data.tokens -= costs[type];
        Game.data.save();
        Game.ui.updateHUD();
        Game.ui.toggleBoostDrawer();

        if (type === 'move') {
            this.moves += 5;
            this.showFloatText("+5 HAMLE", document.getElementById('moves-display'));
        } else if (type === 'shuffle') {
            this.createGrid();
            this.resolveMatches(true);
            this.showFloatText("KARI≈ûTI", document.getElementById('grid'));
        } else if (type === 'smash') {
            for(let r=0; r<this.boardSize; r++){
                for(let c=0; c<this.boardSize; c++){
                    if(this.grid[r][c].type === 0) {
                        this.grid[r][c] = null;
                        this.score += 50;
                    }
                }
            }
            this.applyGravity().then(() => this.resolveMatches());
        }
        Game.ui.updateHUD();
    }

    wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    
    showFloatText(text, targetEl) {
        const rect = targetEl.getBoundingClientRect();
        const float = document.createElement('div');
        float.className = 'float-text';
        float.textContent = text;
        float.style.left = rect.left + 'px';
        float.style.top = rect.top + 'px';
        document.body.appendChild(float);
        setTimeout(() => float.remove(), 800);
    }
    
    restartLevel() { this.initLevel(Game.data.level); }
}

class UIManager {
    constructor() {
        this.overlayMain = document.getElementById('overlay-main');
        this.boostDrawer = document.getElementById('boost-drawer');
    }

    updateLevelInfo(lvl, moves, goal, twist) {
        document.getElementById('level-display').textContent = 'SEVƒ∞YE ' + lvl;
        document.getElementById('moves-display').textContent = moves;
        document.getElementById('score-display').textContent = '0';
        document.getElementById('token-count').textContent = Game.data.tokens;
        
        const goalContainer = document.getElementById('goal-container');
        goalContainer.innerHTML = '';
        if (goal.score) {
            goalContainer.innerHTML = `<div>${goal.score} PUAN</div>`;
        } else {
            goalContainer.innerHTML = `
                <div class="goal-item">
                    <div class="mini-tile" style="background: ${CONSTANTS.COLORS[goal.color]}"></div>
                    <span>x ${goal.count}</span>
                </div>`;
        }

        const twistPanel = document.getElementById('twist-panel');
        if (twist) {
            twistPanel.style.display = 'block';
            document.getElementById('twist-desc').textContent = twist.desc;
        } else {
            twistPanel.style.display = 'none';
        }
    }

    updateHUD() {
        document.getElementById('moves-display').textContent = Game.logic.moves;
        document.getElementById('score-display').textContent = Game.logic.score;
        document.getElementById('token-count').textContent = Game.data.tokens;
        
        const goal = Game.logic.goals;
        if (goal.color !== undefined) {
             document.querySelector('.goal-item span').textContent = `x ${goal.count}`;
        }
    }

    showLevelComplete() {
        this.overlayMain.classList.add('active');
        document.getElementById('overlay-title').textContent = "BA≈ûARDIN!";
        document.getElementById('overlay-title').className = "win-title";
        document.getElementById('overlay-msg').textContent = "+10 Jeton Kazandƒ±n";
        
        Game.data.tokens += 10;
        Game.data.level++;
        Game.data.save();

        document.getElementById('overlay-buttons').innerHTML = `
            <button class="btn" onclick="Game.logic.initLevel(${Game.data.level})">SONRAKƒ∞ SEVƒ∞YE</button>
        `;
    }

    showGameOver() {
        this.overlayMain.classList.add('active');
        document.getElementById('overlay-title').textContent = "HAMLE Bƒ∞TTƒ∞";
        document.getElementById('overlay-title').className = "lose-title";
        document.getElementById('overlay-msg').textContent = "Pes etmek yok!";
        
        document.getElementById('overlay-buttons').innerHTML = `
            <button class="btn btn-boost" onclick="Game.logic.useBooster('move'); Game.ui.closeOverlays()">+5 HAMLE (10 Jeton)</button>
            <button class="btn" style="margin-top:10px" onclick="Game.logic.initLevel(${Game.data.level})">TEKRAR DENE</button>
        `;
    }

    closeOverlays() { this.overlayMain.classList.remove('active'); }
    toggleBoostDrawer() { this.boostDrawer.classList.toggle('open'); }
    toggleSettings() { document.getElementById('overlay-settings').classList.add('active'); }
    
    showHelp() {
        alert("3 Aynƒ± rengi yanyana getir.\nKaydƒ±rarak hareket ettir.\nHedefi tamamla!");
    }
}

const Game = {
    data: new GameData(),
    audio: new AudioController(),
    logic: new GameLogic(),
    ui: new UIManager()
};

window.onload = () => {
    Game.logic.input.attach(document.getElementById('grid'));
    Game.logic.initLevel(Game.data.level);
};

</script>
</body>
</html>
