<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>KIRILMA | Pixel Puzzle</title>
    <style>
        :root {
            --bg-color: #202028; /* Yumu≈üak koyu mavi-gri */
            --panel-bg: #2d2d36;
            --text-main: #f0f0f0;
            --text-muted: #a0a0b0;
            
            /* Pastel Pixel Paleti */
            --pixel-red: #e74c3c;
            --pixel-cyan: #3498db;
            --pixel-green: #2ecc71;
            --pixel-yellow: #f1c40f;
            --pixel-magenta: #9b59b6;
            
            --border-color: #111;
            --tile-size: 56px;
            --gap: 2px;
            
            --font-ui: 'Courier New', Courier, monospace; /* Retro font */
        }

        * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-ui);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            image-rendering: pixelated; /* Pixel art keskinliƒüi */
        }

        /* Layout Structure */
        #app {
            width: 100%;
            max-width: 600px; /* Daha kompakt mobil odaklƒ± */
            height: 100%;
            display: flex;
            flex-direction: column;
            padding: 10px;
            position: relative;
            z-index: 10;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 4px solid var(--border-color);
            margin-bottom: 10px;
            background: var(--panel-bg);
            padding: 10px;
            border-radius: 4px;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            font-weight: 900;
            letter-spacing: -1px;
            text-transform: uppercase;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
        }

        .level-badge {
            background: #444;
            padding: 5px 10px;
            font-weight: bold;
            border: 2px solid #000;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
            font-size: 0.9rem;
        }

        .icon-btn {
            background: #555;
            border: 2px solid #000;
            color: #fff;
            padding: 5px 10px;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 2px 2px 0 rgba(0,0,0,0.5);
        }
        .icon-btn:active { transform: translate(2px, 2px); box-shadow: none; }

        /* Main Game Area */
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            overflow: hidden;
        }

        /* Game Board */
        #game-board-container {
            position: relative;
            padding: 8px;
            background: #181818;
            border: 4px solid var(--border-color);
            border-radius: 4px;
            box-shadow: 5px 5px 0 rgba(0,0,0,0.3);
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: var(--gap);
            width: fit-content;
            touch-action: none; /* Mobilde kaydƒ±rmayƒ± engelle, oyuna ver */
        }

        .tile {
            width: var(--tile-size);
            height: var(--tile-size);
            background: #333;
            cursor: pointer;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s;
            will-change: transform;
            /* Pixel Art Style Tile */
            box-shadow: inset 3px 3px 0 rgba(255,255,255,0.3), inset -3px -3px 0 rgba(0,0,0,0.3);
            border: 1px solid #000;
        }

        /* Tile Shapes & Colors (Flat Pixel Style) */
        .tile[data-type="0"] { background-color: var(--pixel-red); }
        .tile[data-type="0"]::after { content:'‚ñ†'; color:rgba(0,0,0,0.3); font-size:24px; } /* Kare */

        .tile[data-type="1"] { background-color: var(--pixel-cyan); }
        .tile[data-type="1"]::after { content:'‚óè'; color:rgba(0,0,0,0.3); font-size:24px; } /* Daire */

        .tile[data-type="2"] { background-color: var(--pixel-green); }
        .tile[data-type="2"]::after { content:'‚ñ≤'; color:rgba(0,0,0,0.3); font-size:20px; } /* √ú√ßgen */

        .tile[data-type="3"] { background-color: var(--pixel-yellow); }
        .tile[data-type="3"]::after { content:'‚óÜ'; color:rgba(0,0,0,0.3); font-size:24px; } /* Elmas */

        .tile[data-type="4"] { background-color: var(--pixel-magenta); }
        .tile[data-type="4"]::after { content:'‚òÖ'; color:rgba(0,0,0,0.3); font-size:20px; } /* Yƒ±ldƒ±z */

        .tile.selected { filter: brightness(1.2); transform: scale(0.95); border: 2px solid #fff; }
        .tile.matched { animation: pop 0.2s forwards; }
        
        .tile.cracked {
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(0,0,0,0.2) 5px, rgba(0,0,0,0.2) 10px);
        }

        /* HUD Panel */
        #hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .panel {
            flex: 1;
            background: var(--panel-bg);
            border: 2px solid #000;
            padding: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 3px 3px 0 rgba(0,0,0,0.2);
        }

        .stat-label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; font-weight: bold; }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #fff; margin-top: 2px; text-shadow: 2px 2px 0 #000; }
        
        .twist-panel { 
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 90%; z-index: 5;
            background: #222; border: 2px solid var(--pixel-yellow); 
            display: none; padding: 5px; text-align: center;
            font-size: 0.8rem; color: var(--pixel-yellow);
        }

        .goal-item { display: flex; align-items: center; gap: 5px; margin-top: 5px; font-size: 0.9rem; font-weight: bold;}
        .mini-tile { width: 14px; height: 14px; border: 1px solid #000; display: inline-block;}

        .btn {
            background: #4a69bd;
            border: 2px solid #000;
            color: #fff;
            padding: 10px;
            width: 100%;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            font-family: inherit;
            box-shadow: 3px 3px 0 #000;
            font-size: 0.9rem;
        }
        .btn:active { transform: translate(3px, 3px); box-shadow: none; }
        
        .btn-boost { background: #e58e26; }
        .btn-secondary { background: #60a3bc; font-size: 0.8rem; padding: 8px;}

        /* Tokens Display */
        #token-display { display: flex; align-items: center; gap: 5px; font-weight: bold; color: var(--pixel-yellow); }
        .token-icon { width: 12px; height: 12px; background: var(--pixel-yellow); border: 1px solid #000; border-radius: 50%; }

        /* Overlays */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 100;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }
        .overlay.active { display: flex; }
        .overlay-content { 
            width: 85%; padding: 20px; 
            background: var(--panel-bg); border: 4px solid #fff; 
            box-shadow: 10px 10px 0 #000;
        }
        
        .overlay h2 { font-size: 2rem; margin-bottom: 20px; text-shadow: 3px 3px 0 #000; }
        .win-title { color: var(--pixel-green); }
        .lose-title { color: var(--pixel-red); }
        
        /* Boost Drawer */
        #boost-drawer {
            position: absolute; bottom: -300px; left: 0; width: 100%; height: auto;
            background: #222; border-top: 4px solid var(--pixel-green);
            z-index: 50; transition: bottom 0.3s ease;
            padding: 20px; box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
        }
        #boost-drawer.open { bottom: 0; }

        .boost-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; border: 2px solid #444; background: #333;
            margin-bottom: 10px; cursor: pointer;
        }
        .boost-item:active { background: #444; }

        /* Bottom Bar */
        footer {
            margin-top: auto;
            width: 100%;
            padding: 5px;
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #888;
        }

        /* Animations */
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.2); opacity: 1; } 100% { transform: scale(0); opacity: 0; } }
        @keyframes floatUp { 0% { transform: translateY(0); opacity: 1; } 100% { transform: translateY(-30px); opacity: 0; } }
        
        .float-text {
            position: absolute; color: #fff; font-weight: bold; font-size: 1.2rem;
            pointer-events: none; animation: floatUp 0.8s forwards; z-index: 20;
            text-shadow: 2px 2px 0 #000;
        }

        /* Responsive */
        @media (max-width: 768px) {
            :root { --tile-size: 11vw; --gap: 2px; }
            #hud { flex-direction: row; flex-wrap: wrap; }
            .panel { min-width: 80px; }
        }

    </style>
</head>
<body>

<div id="app">
    <header>
        <h1>KIRILMA</h1>
        <div class="level-badge" id="level-display">SEVƒ∞YE 1</div>
        <div style="display:flex; gap:10px; align-items: center;">
            <div id="token-display"><div class="token-icon"></div> <span id="token-count">0</span></div>
            <button class="icon-btn" onclick="Game.ui.toggleSettings()">‚öôÔ∏è</button>
        </div>
    </header>

    <main>
        <div class="twist-panel" id="twist-panel">
            <span id="twist-desc">...</span>
        </div>

        <div id="hud">
            <div class="panel">
                <div class="stat-label">HAMLE</div>
                <div class="stat-value" id="moves-display">20</div>
            </div>
            
            <div class="panel">
                <div class="stat-label">HEDEF</div>
                <div id="goal-container"></div>
            </div>

            <div class="panel">
                <div class="stat-label">PUAN</div>
                <div class="stat-value" style="font-size: 1.2rem" id="score-display">0</div>
            </div>
        </div>

        <div id="game-board-container">
            <!-- Grid is touch-action: none via CSS to allow dragging -->
            <div id="grid"></div>
        </div>

        <div style="width:100%; display: flex; gap: 5px; margin-top: 10px;">
            <button class="btn btn-boost" onclick="Game.ui.toggleBoostDrawer()">‚ö° G√ú√áLENDƒ∞Rƒ∞Cƒ∞</button>
            <button class="btn btn-secondary" onclick="Game.logic.restartLevel()">TEKRAR</button>
        </div>
    </main>

    <footer>
        <button class="icon-btn" id="sound-toggle" style="border:none; padding:0; background:none; box-shadow:none" onclick="Game.audio.toggle()">üîä</button>
        <span id="tip-text">Deƒüi≈ütirmek i√ßin s√ºr√ºkleyin!</span>
        <button class="icon-btn" style="border:none; padding:0; background:none; box-shadow:none" onclick="Game.ui.showHelp()">Yardƒ±m ?</button>
    </footer>

    <!-- Boost Drawer -->
    <div id="boost-drawer">
        <h3 style="color:var(--pixel-green); margin-top:0; border-bottom: 2px solid #555; padding-bottom:5px;">MARKET</h3>
        <button class="icon-btn" onclick="Game.ui.toggleBoostDrawer()" style="position:absolute; top:10px; right:10px; background:#e74c3c;">X</button>
        
        <div class="boost-item" onclick="Game.logic.useBooster('move')">
            <span><b>+5 HAMLE</b></span> 
            <span style="color:var(--pixel-yellow)">10 Jeton</span>
        </div>
        
        <div class="boost-item" onclick="Game.logic.useBooster('shuffle')">
            <span><b>KARI≈ûTIR</b></span> 
            <span style="color:var(--pixel-yellow)">15 Jeton</span>
        </div>
        
        <div class="boost-item" onclick="Game.logic.useBooster('smash')">
            <span><b>RENK Sƒ∞L</b> (Kƒ±rmƒ±zƒ±)</span> 
            <span style="color:var(--pixel-yellow)">25 Jeton</span>
        </div>
    </div>
</div>

<!-- Overlays -->
<div id="overlay-main" class="overlay">
    <div class="overlay-content">
        <h2 id="overlay-title">B√ñL√úM GE√áƒ∞LDƒ∞</h2>
        <p id="overlay-msg" style="margin-bottom:20px; font-size:1.1rem; color:#ccc;"></p>
        <div id="overlay-buttons"></div>
    </div>
</div>

<div id="overlay-settings" class="overlay">
    <div class="overlay-content">
        <h2>AYARLAR</h2>
        <button class="btn" style="background:#e74c3c; margin-top:10px" onclick="Game.data.resetProgress(); location.reload()">ƒ∞lerlemeyi Sƒ±fƒ±rla</button>
        <button class="btn btn-secondary" style="margin-top:10px" onclick="document.getElementById('overlay-settings').classList.remove('active')">KAPAT</button>
    </div>
</div>

<script>
/**
 * KIRILMA: Pixel Edition - Game Logic
 */

const CONSTANTS = {
    ROWS: 8,
    COLS: 8,
    COLORS: ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6'], // Pixel Palet
    TYPES: [0, 1, 2, 3, 4],
    SWIPE_THRESHOLD: 30 // Minimum pixel distance for swipe
};

const TWISTS = {
    NONE: null,
    BLUE_PHANTOM: { id: 'BLUE_PHANTOM', desc: "Mavi daireler puan vermez." },
    ANTI_GRAVITY: { id: 'ANTI_GRAVITY', desc: "Yer√ßekimi yok! Bo≈üluklar rastgele dolar." },
    CRACKED_HULL: { id: 'CRACKED_HULL', desc: "Ta≈ülar sertle≈üti. Kƒ±rmak i√ßin 2 kez e≈üle." },
    CONTAINMENT: { id: 'CONTAINMENT', desc: "Alan daraldƒ±! (6x6)" },
    SPECTRUM_BAN: { id: 'SPECTRUM_BAN', desc: "Sarƒ± ta≈ülar bu b√∂l√ºmde yok." },
    STICKY_CORE: { id: 'STICKY_CORE', desc: "Yapƒ±≈ükan: Orta sƒ±ra a≈üaƒüƒ± d√º≈ümez." }
};

class GameData {
    constructor() {
        this.level = 1;
        this.tokens = 50;
        this.settings = { sound: true };
        this.load();
    }

    load() {
        const saved = localStorage.getItem('kirilma_pixel_save');
        if (saved) {
            const parsed = JSON.parse(saved);
            this.level = parsed.level || 1;
            this.tokens = parsed.tokens || 50;
        }
    }

    save() {
        localStorage.setItem('kirilma_pixel_save', JSON.stringify({
            level: this.level,
            tokens: this.tokens
        }));
    }

    resetProgress() {
        localStorage.removeItem('kirilma_pixel_save');
    }
}

class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }

    toggle() {
        this.enabled = !this.enabled;
        document.getElementById('sound-toggle').textContent = this.enabled ? 'üîä' : 'üîá';
    }

    playTone(freq, type, duration) {
        if (!this.enabled) return;
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        } catch(e) {}
    }

    playPop() { this.playTone(300, 'square', 0.05); } // Short blip
    playMatch() { 
        this.playTone(400, 'sine', 0.1); 
        setTimeout(() => this.playTone(600, 'sine', 0.1), 80);
    }
    playError() { this.playTone(150, 'sawtooth', 0.2); }
    playWin() { 
        [523, 659, 784, 1046].forEach((f, i) => setTimeout(() => this.playTone(f, 'square', 0.2), i*100));
    }
}

class InputController {
    constructor(gameLogic) {
        this.logic = gameLogic;
        this.startX = 0;
        this.startY = 0;
        this.activeTile = null;
        this.isDragging = false;
    }

    attach(element) {
        // Touch Events
        element.addEventListener('touchstart', (e) => this.handleStart(e.touches[0].clientX, e.touches[0].clientY, e.target), {passive: false});
        element.addEventListener('touchmove', (e) => this.handleMove(e.touches[0].clientX, e.touches[0].clientY, e), {passive: false});
        element.addEventListener('touchend', (e) => this.handleEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY));

        // Mouse Events
        element.addEventListener('mousedown', (e) => this.handleStart(e.clientX, e.clientY, e.target));
        window.addEventListener('mousemove', (e) => {
            if(this.isDragging) this.handleMove(e.clientX, e.clientY, e);
        });
        window.addEventListener('mouseup', (e) => {
            if(this.isDragging) this.handleEnd(e.clientX, e.clientY);
        });
    }

    getTileFromTarget(target) {
        if(target.classList.contains('tile')) return target;
        return target.closest('.tile');
    }

    handleStart(x, y, target) {
        if (this.logic.isProcessing) return;
        const tileEl = this.getTileFromTarget(target);
        if (!tileEl) return;

        this.startX = x;
        this.startY = y;
        this.activeTile = {
            r: parseInt(tileEl.dataset.r),
            c: parseInt(tileEl.dataset.c),
            el: tileEl
        };
        this.isDragging = true;
        
        // Visual feedback
        tileEl.style.transform = "scale(0.9)";
    }

    handleMove(x, y, e) {
        if(!this.isDragging) return;
        e.preventDefault(); // Stop scrolling while playing
    }

    handleEnd(x, y) {
        if (!this.isDragging || !this.activeTile) return;
        this.isDragging = false;
        
        // Reset visual
        this.activeTile.el.style.transform = "";

        const diffX = x - this.startX;
        const diffY = y - this.startY;

        // Determine direction
        if (Math.abs(diffX) < CONSTANTS.SWIPE_THRESHOLD && Math.abs(diffY) < CONSTANTS.SWIPE_THRESHOLD) {
            // It was just a tap, do nothing or handle selection if we wanted click support too
            return; 
        }

        let targetR = this.activeTile.r;
        let targetC = this.activeTile.c;

        if (Math.abs(diffX) > Math.abs(diffY)) {
            // Horizontal
            if (diffX > 0) targetC++; else targetC--;
        } else {
            // Vertical
            if (diffY > 0) targetR++; else targetR--;
        }

        // Check bounds
        if (targetR >= 0 && targetR < this.logic.boardSize && targetC >= 0 && targetC < this.logic.boardSize) {
            this.logic.attemptSwap(this.activeTile, {r: targetR, c: targetC});
        } else {
            // Out of bounds swipe
            Game.audio.playError();
        }
        
        this.activeTile = null;
    }
}

class GameLogic {
    constructor() {
        this.grid = [];
        this.isProcessing = false;
        this.score = 0;
        this.moves = 0;
        this.goals = {};
        this.currentTwist = null;
        this.boardSize = 8;
        this.bannedColor = -1;
        
        this.input = new InputController(this);
    }

    initLevel(levelNum) {
        this.score = 0;
        this.moves = Math.max(15, 30 - Math.floor(levelNum / 2));
        this.goals = this.generateGoals(levelNum);
        this.currentTwist = this.getTwistForLevel(levelNum);
        
        this.boardSize = (this.currentTwist === TWISTS.CONTAINMENT) ? 6 : 8;
        this.bannedColor = (this.currentTwist === TWISTS.SPECTRUM_BAN) ? 3 : -1;

        Game.ui.updateLevelInfo(levelNum, this.moves, this.goals, this.currentTwist);
        Game.ui.closeOverlays();
        
        this.createGrid();
        this.resolveMatches(true);
    }

    getTwistForLevel(lvl) {
        if (lvl < 5) return TWISTS.NONE;
        if (lvl >= 5 && lvl < 10) return TWISTS.BLUE_PHANTOM;
        if (lvl >= 10 && lvl < 15) return TWISTS.ANTI_GRAVITY;
        if (lvl >= 15 && lvl < 20) return TWISTS.CRACKED_HULL;
        if (lvl >= 20 && lvl < 25) return TWISTS.CONTAINMENT;
        if (lvl >= 25 && lvl < 30) return TWISTS.SPECTRUM_BAN;
        if (lvl >= 30) return TWISTS.STICKY_CORE;
        return TWISTS.NONE;
    }

    generateGoals(lvl) {
        const targetScore = lvl * 800;
        const colorTarget = 10 + Math.floor(lvl * 1.5);
        if (lvl % 3 === 0) return { score: targetScore };
        if (lvl % 3 === 1) return { color: 0, count: colorTarget };
        return { color: 2, count: colorTarget };
    }

    createGrid() {
        const gridEl = document.getElementById('grid');
        gridEl.innerHTML = '';
        gridEl.style.gridTemplateColumns = `repeat(${this.boardSize}, 1fr)`;
        this.grid = [];

        // Attach input listener to grid container
        // Remove old listeners? For simple page refresh logic, not needed.
        // But better to attach once. We'll attach in main init.

        for (let r = 0; r < this.boardSize; r++) {
            this.grid[r] = [];
            for (let c = 0; c < this.boardSize; c++) {
                this.grid[r][c] = this.spawnTileData(r, c);
                this.createTileDOM(r, c);
            }
        }
    }

    spawnTileData(r, c) {
        let type;
        do { type = Math.floor(Math.random() * 5); } while (type === this.bannedColor);
        return {
            type: type,
            r: r, c: c,
            el: null,
            cracked: (this.currentTwist === TWISTS.CRACKED_HULL)
        };
    }

    createTileDOM(r, c) {
        const data = this.grid[r][c];
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.dataset.type = data.type;
        tile.dataset.r = r;
        tile.dataset.c = c;
        if (data.cracked) tile.classList.add('cracked');
        
        document.getElementById('grid').appendChild(tile);
        data.el = tile;
    }

    // --- Interaction ---

    attemptSwap(t1Coords, t2Coords) {
        const t1 = this.grid[t1Coords.r][t1Coords.c];
        const t2 = this.grid[t2Coords.r][t2Coords.c];
        this.swapTiles(t1, t2);
    }

    async swapTiles(t1, t2) {
        this.isProcessing = true;
        
        // Visual Swap Logic
        this.grid[t1.r][t1.c] = t2;
        this.grid[t2.r][t2.c] = t1;
        
        const tempR = t1.r, tempC = t1.c;
        t1.r = t2.r; t1.c = t2.c;
        t2.r = tempR; t2.c = tempC;

        this.updateTileVisuals(t1);
        this.updateTileVisuals(t2);

        await this.wait(150);

        const matches = this.findMatches();
        
        if (matches.length > 0) {
            this.moves--;
            Game.ui.updateHUD();
            await this.resolveMatches(false, matches);
        } else {
            Game.audio.playError();
            // Swap Back
            this.grid[t1.r][t1.c] = t2;
            this.grid[t2.r][t2.c] = t1;
            t1.r = t2.r; t1.c = t2.c;
            t2.r = tempR; t2.c = tempC;
            
            // Fix coordinates back
             const r1 = t1.r; const c1 = t1.c;
            t1.r = t2.r; t1.c = t2.c;
            t2.r = r1; t2.c = c1;

            this.updateTileVisuals(t1);
            this.updateTileVisuals(t2);
            this.isProcessing = false;
        }
    }

    updateTileVisuals(tileData) {
        const el = tileData.el;
        el.dataset.type = tileData.type;
        el.className = 'tile';
        if (tileData.cracked) el.classList.add('cracked');
        el.dataset.r = tileData.r;
        el.dataset.c = tileData.c;
    }

    findMatches() {
        const matches = new Set();
        // Horizontal
        for (let r = 0; r < this.boardSize; r++) {
            for (let c = 0; c < this.boardSize - 2; c++) {
                const type = this.grid[r][c].type;
                if (type === this.grid[r][c+1].type && type === this.grid[r][c+2].type) {
                    matches.add(this.grid[r][c]); matches.add(this.grid[r][c+1]); matches.add(this.grid[r][c+2]);
                }
            }
        }
        // Vertical
        for (let c = 0; c < this.boardSize; c++) {
            for (let r = 0; r < this.boardSize - 2; r++) {
                const type = this.grid[r][c].type;
                if (type === this.grid[r+1][c].type && type === this.grid[r+2][c].type) {
                    matches.add(this.grid[r][c]); matches.add(this.grid[r+1][c]); matches.add(this.grid[r+2][c]);
                }
            }
        }
        return Array.from(matches);
    }

    async resolveMatches(silent = false, initialMatches = null) {
        let matches = initialMatches || this.findMatches();
        let cascadeCount = 0;

        while (matches.length > 0) {
            cascadeCount++;
            if (!silent) {
                Game.audio.playMatch();
                if(cascadeCount > 1) this.showFloatText("KOMBO!", matches[0].el);
            }

            let tilesToRemove = [];
            for (let t of matches) {
                if (this.currentTwist === TWISTS.BLUE_PHANTOM && t.type === 1) {
                    // Ghost
                } else if (!silent) {
                    this.score += 10 * cascadeCount;
                    if (this.goals.color !== undefined && this.goals.color === t.type) {
                        this.goals.count = Math.max(0, this.goals.count - 1);
                    }
                }

                if (this.currentTwist === TWISTS.CRACKED_HULL && t.cracked && !silent) {
                    t.cracked = false;
                    this.updateTileVisuals(t);
                } else {
                    tilesToRemove.push(t);
                }
            }

            if (!silent) {
                tilesToRemove.forEach(t => t.el.classList.add('matched'));
                await this.wait(200);
            }

            tilesToRemove.forEach(t => {
                this.grid[t.r][t.c] = null;
                t.el.remove();
            });

            await this.applyGravity();
            matches = this.findMatches();
            if (!silent) Game.ui.updateHUD();
        }

        this.isProcessing = false;
        if (!silent) this.checkGameState();
    }

    async applyGravity() {
        if (this.currentTwist === TWISTS.ANTI_GRAVITY) {
            for (let r = 0; r < this.boardSize; r++) {
                for (let c = 0; c < this.boardSize; c++) {
                    if (this.grid[r][c] === null) {
                        const newData = this.spawnTileData(r, c);
                        this.grid[r][c] = newData;
                        this.createTileDOM(r, c);
                    }
                }
            }
            this.rebuildGridDOM();
            await this.wait(50);
            return;
        }

        for (let c = 0; c < this.boardSize; c++) {
            let emptySlots = 0;
            for (let r = this.boardSize - 1; r >= 0; r--) {
                if (this.currentTwist === TWISTS.STICKY_CORE && (r === 3 || r === 4)) {
                     if (this.grid[r][c] === null) this.grid[r][c] = this.spawnTileData(r, c);
                     continue;
                }
                if (this.grid[r][c] === null) {
                    emptySlots++;
                } else if (emptySlots > 0) {
                    const tile = this.grid[r][c];
                    this.grid[r + emptySlots][c] = tile;
                    tile.r = r + emptySlots;
                    this.grid[r][c] = null;
                }
            }
            for (let r = 0; r < emptySlots; r++) {
                this.grid[r][c] = this.spawnTileData(r, c);
            }
        }
        this.rebuildGridDOM();
        await this.wait(100);
    }

    rebuildGridDOM() {
        const container = document.getElementById('grid');
        container.innerHTML = '';
        for (let r = 0; r < this.boardSize; r++) {
            for (let c = 0; c < this.boardSize; c++) {
                const t = this.grid[r][c];
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.dataset.type = t.type;
                if(t.cracked) tile.classList.add('cracked');
                tile.dataset.r = r;
                tile.dataset.c = c;
                t.el = tile;
                container.appendChild(tile);
            }
        }
    }

    checkGameState() {
        let won = false;
        if (this.goals.score && this.score >= this.goals.score) won = true;
        if (this.goals.color !== undefined && this.goals.count <= 0) won = true;

        if (won) {
            Game.audio.playWin();
            Game.ui.showLevelComplete();
            return;
        }
        if (this.moves <= 0) {
            Game.ui.showGameOver();
        }
    }

    useBooster(type) {
        if (this.isProcessing) return;
        const costs = { move: 10, shuffle: 15, smash: 25 };
        if (Game.data.tokens < costs[type]) {
            alert("Yetersiz Jeton!");
            return;
        }
        Game.data.tokens -= costs[type];
        Game.data.save();
        Game.ui.updateHUD();
        Game.ui.toggleBoostDrawer();

        if (type === 'move') {
            this.moves += 5;
            this.showFloatText("+5 HAMLE", document.getElementById('moves-display'));
        } else if (type === 'shuffle') {
            this.createGrid();
            this.resolveMatches(true);
            this.showFloatText("KARI≈ûTI", document.getElementById('grid'));
        } else if (type === 'smash') {
            for(let r=0; r<this.boardSize; r++){
                for(let c=0; c<this.boardSize; c++){
                    if(this.grid[r][c].type === 0) {
                        this.grid[r][c] = null;
                        this.score += 50;
                    }
                }
            }
            this.applyGravity().then(() => this.resolveMatches());
        }
        Game.ui.updateHUD();
    }

    wait(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    
    showFloatText(text, targetEl) {
        const rect = targetEl.getBoundingClientRect();
        const float = document.createElement('div');
        float.className = 'float-text';
        float.textContent = text;
        float.style.left = rect.left + 'px';
        float.style.top = rect.top + 'px';
        document.body.appendChild(float);
        setTimeout(() => float.remove(), 800);
    }
    
    restartLevel() { this.initLevel(Game.data.level); }
}

class UIManager {
    constructor() {
        this.overlayMain = document.getElementById('overlay-main');
        this.boostDrawer = document.getElementById('boost-drawer');
    }

    updateLevelInfo(lvl, moves, goal, twist) {
        document.getElementById('level-display').textContent = 'SEVƒ∞YE ' + lvl;
        document.getElementById('moves-display').textContent = moves;
        document.getElementById('score-display').textContent = '0';
        document.getElementById('token-count').textContent = Game.data.tokens;
        
        const goalContainer = document.getElementById('goal-container');
        goalContainer.innerHTML = '';
        if (goal.score) {
            goalContainer.innerHTML = `<div>${goal.score} PUAN</div>`;
        } else {
            goalContainer.innerHTML = `
                <div class="goal-item">
                    <div class="tile mini-tile" style="background-color:${CONSTANTS.COLORS[goal.color]}"></div>
                    <span>x ${goal.count}</span>
                </div>`;
        }

        const twistPanel = document.getElementById('twist-panel');
        if (twist) {
            twistPanel.style.display = 'block';
            document.getElementById('twist-desc').textContent = twist.desc;
        } else {
            twistPanel.style.display = 'none';
        }
    }

    updateHUD() {
        document.getElementById('moves-display').textContent = Game.logic.moves;
        document.getElementById('score-display').textContent = Game.logic.score;
        document.getElementById('token-count').textContent = Game.data.tokens;
        
        const goal = Game.logic.goals;
        if (goal.color !== undefined) {
             document.querySelector('.goal-item span').textContent = `x ${goal.count}`;
        }
    }

    showLevelComplete() {
        this.overlayMain.classList.add('active');
        document.getElementById('overlay-title').textContent = "BA≈ûARDIN!";
        document.getElementById('overlay-title').className = "win-title";
        document.getElementById('overlay-msg').textContent = "+10 Jeton Kazandƒ±n";
        
        Game.data.tokens += 10;
        Game.data.level++;
        Game.data.save();

        document.getElementById('overlay-buttons').innerHTML = `
            <button class="btn" onclick="Game.logic.initLevel(${Game.data.level})">SONRAKƒ∞ SEVƒ∞YE</button>
        `;
    }

    showGameOver() {
        this.overlayMain.classList.add('active');
        document.getElementById('overlay-title').textContent = "HAMLE Bƒ∞TTƒ∞";
        document.getElementById('overlay-title').className = "lose-title";
        document.getElementById('overlay-msg').textContent = "Pes etmek yok!";
        
        document.getElementById('overlay-buttons').innerHTML = `
            <button class="btn btn-boost" onclick="Game.logic.useBooster('move'); Game.ui.closeOverlays()">+5 HAMLE (10 Jeton)</button>
            <button class="btn" style="margin-top:10px" onclick="Game.logic.initLevel(${Game.data.level})">TEKRAR DENE</button>
        `;
    }

    closeOverlays() { this.overlayMain.classList.remove('active'); }
    toggleBoostDrawer() { this.boostDrawer.classList.toggle('open'); }
    toggleSettings() { document.getElementById('overlay-settings').classList.add('active'); }
    
    showHelp() {
        alert("3 Aynƒ± rengi yanyana getir.\nKaydƒ±rarak hareket ettir.\nHedefi tamamla!");
    }
}

const Game = {
    data: new GameData(),
    audio: new AudioController(),
    logic: new GameLogic(),
    ui: new UIManager()
};

window.onload = () => {
    Game.logic.input.attach(document.getElementById('grid'));
    Game.logic.initLevel(Game.data.level);
};

</script>
</body>
</html>
